<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IR Log Viewer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üîç</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1600px;
            width: 100%;
            padding: 40px 50px;
        }

        h1 {
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 1.9em;
        }

        .subtitle {
            color: #718096;
            margin-bottom: 16px;
            font-size: 1.05em;
        }

        /* Status Bar */
        .status-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .status-bar:hover {
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .status-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            font-size: 1.5em;
        }

        .status-text {
            font-size: 1.1em;
            font-weight: 500;
        }

        .status-count {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
            opacity: 0.9;
        }

        .reload-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .reload-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .reload-btn:active {
            transform: scale(0.95);
        }

        .reload-btn.loading {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .reload-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .reload-btn.loading .reload-icon {
            animation: spin 1s linear infinite;
        }

        .expand-icon {
            transition: transform 0.3s ease;
        }

        .status-bar.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .status-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .status-bar.expanded .status-details {
            max-height: 600px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .bot-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bot-status-item:last-child {
            border-bottom: none;
        }

        .bot-status-name {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bot-status-controls {
            display: flex;
            gap: 6px;
        }

        .btn-small {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-small:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Log Grid */
        .log-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 18px;
            margin-bottom: 18px;
        }

        .log-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 24px;
            padding-bottom: 165px;
            text-decoration: none;
            color: white;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            min-height: 240px;
            display: flex;
            flex-direction: column;
        }

        .log-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
        }

        .log-card.featured {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding-bottom: 24px;
            min-height: auto;
        }

        .log-card.status-down {
            background: linear-gradient(135deg, #fc5c7d 0%, #6a82fb 100%);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .log-card h3 {
            font-size: 1.3em;
            margin: 0;
        }

        .card-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85em;
            opacity: 0.95;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 2s infinite;
        }

        .status-dot.running {
            background: #48bb78;
        }

        .status-dot.stopped {
            background: #f56565;
            animation: none;
        }

        .status-dot.error {
            background: #ed8936;
            animation: blink 1s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.3;
            }
        }

        .log-card p {
            opacity: 0.9;
            font-size: 0.9em;
            margin: 0;
        }

        /* Card Overlay */
        .card-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            opacity: 1;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-overlay-content {
            font-size: 0.82em;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .card-overlay-content div {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        .card-overlay-content .metric-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            line-height: 1;
        }

        .card-overlay-content .metric-label {
            width: 60px;
            flex-shrink: 0;
            text-align: left;
        }

        .card-overlay-content .metric-value {
            width: 110px;
            flex-shrink: 0;
            text-align: right;
        }

        .card-overlay-content .progress-bar {
            flex: 1;
            margin-top: 0;
            margin-left: 8px;
            align-self: center;
        }

        .card-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .btn-card {
            flex: 1;
            min-width: 75px;
            background: rgba(255, 255, 255, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 7px 11px;
            border-radius: 6px;
            font-size: 0.78em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            font-weight: 500;
        }

        .btn-card:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
            transform: translateY(-1px);
        }

        .btn-card:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-card.btn-start {
            background: rgba(72, 187, 120, 0.3);
            border-color: rgba(72, 187, 120, 0.5);
        }

        .btn-card.btn-start:hover {
            background: rgba(72, 187, 120, 0.5);
        }

        .btn-card.btn-stop {
            background: rgba(245, 101, 101, 0.3);
            border-color: rgba(245, 101, 101, 0.5);
        }

        .btn-card.btn-stop:hover {
            background: rgba(245, 101, 101, 0.5);
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 16px 20px;
            max-width: 350px;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.success {
            border-left: 4px solid #48bb78;
        }

        .toast.error {
            border-left: 4px solid #f56565;
        }

        .toast.info {
            border-left: 4px solid #4299e1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #2d3748;
        }

        .toast-message {
            font-size: 0.9em;
            color: #4a5568;
        }

        /* Features */
        .features {
            background: #f7fafc;
            border-radius: 12px;
            padding: 20px 30px;
            margin-top: 20px;
        }

        .features h3 {
            color: #2d3748;
            margin-bottom: 12px;
        }

        .features ul {
            list-style: none;
            color: #4a5568;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px 20px;
        }

        .features li {
            padding: 6px 0;
            padding-left: 24px;
            position: relative;
        }

        .features li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #48bb78;
            font-weight: bold;
        }

        .footer {
            text-align: center;
            margin-top: 16px;
            color: #a0aec0;
            font-size: 0.9em;
        }

        /* Loading Spinner */
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Status Change Animations */
        @keyframes statusChange {
            0% {
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 30px rgba(72, 187, 120, 0.6), 0 8px 12px rgba(0, 0, 0, 0.2);
                transform: translateY(-6px) scale(1.02);
            }
            100% {
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
        }

        @keyframes statusChangeDown {
            0% {
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
            50% {
                box-shadow: 0 0 30px rgba(245, 101, 101, 0.6), 0 8px 12px rgba(0, 0, 0, 0.2);
                transform: translateY(-6px) scale(1.02);
            }
            100% {
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
        }

        .log-card.status-change-up {
            animation: statusChange 1.5s ease-out;
        }

        .log-card.status-change-down {
            animation: statusChangeDown 1.5s ease-out;
        }

        /* Progress Bar Styles */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 4px;
            display: flex;
            align-items: stretch;
        }

        .progress-fill {
            height: 6px;
            display: block;
            line-height: 1;
            font-size: 0;
            overflow: hidden;
            transition: width 0.5s ease, background-color 0.3s ease;
        }

        .progress-fill.low {
            background: #48bb78;
        }

        .progress-fill.medium {
            background: #ecc94b;
        }

        .progress-fill.high {
            background: #f56565;
        }

        /* Uptime Badge */
        .uptime-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.25);
            margin-left: 6px;
        }

        .uptime-badge.excellent {
            background: rgba(72, 187, 120, 0.3);
            border: 1px solid rgba(72, 187, 120, 0.5);
        }

        .uptime-badge.good {
            background: rgba(236, 201, 75, 0.3);
            border: 1px solid rgba(236, 201, 75, 0.5);
        }

        .uptime-badge.poor {
            background: rgba(245, 101, 101, 0.3);
            border: 1px solid rgba(245, 101, 101, 0.5);
        }

        /* Quick Actions Toolbar */
        .quick-actions {
            background: #f7fafc;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .quick-actions-title {
            color: #2d3748;
            font-weight: 600;
            font-size: 1em;
        }

        .quick-actions-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-action {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .btn-action:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn-action:active {
            transform: translateY(0);
        }

        .btn-action:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-action.btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }

        .btn-action.btn-danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }

        .btn-action.btn-warning {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
        }

        /* Trend Indicators */
        .trend-indicator {
            display: inline-block;
            margin-left: 4px;
            font-size: 0.9em;
        }

        .trend-up {
            color: #f56565;
        }

        .trend-down {
            color: #48bb78;
        }

        .trend-stable {
            color: #cbd5e0;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>üîç IR Log Viewer</h1>
    <p class="subtitle">Real-time log monitoring for all IR services</p>

    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
        <div class="status-summary">
            <div class="status-left">
                <span class="status-indicator" id="statusIndicator">‚è≥</span>
                <div>
                    <div class="status-text" id="statusText">Loading...</div>
                    <div class="status-count" id="statusCount">Checking bot status...</div>
                </div>
            </div>
            <div class="status-right">
                <span id="lastUpdate">Just now</span>
                <button class="reload-btn" id="pauseBtn" onclick="togglePause()" title="Pause auto-refresh">
                    <span id="pauseIcon">‚è∏Ô∏è</span>
                </button>
                <button class="reload-btn" id="reloadBtn" onclick="manualRefresh()">
                    <span class="reload-icon">üîÑ</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Quick Actions Toolbar -->
    <div class="quick-actions">
        <div class="quick-actions-title">Quick Actions</div>
        <div class="quick-actions-buttons">
            <button class="btn-action btn-success" onclick="controlAllBots('start')" id="startAllBtn">
                Start All Stopped
            </button>
            <button class="btn-action btn-warning" onclick="controlAllBots('restart')" id="restartAllBtn">
                Restart All Running
            </button>
            <button class="btn-action btn-danger" onclick="controlAllBots('stop')" id="stopAllBtn">
                Stop All Running
            </button>
            <button class="btn-action" onclick="restartLogViewers()" id="restartLogViewersBtn">
                üîÑ Restart Log Viewers
            </button>
            <button class="btn-action" onclick="restartSelf()" id="restartSelfBtn">
                üîß Restart This Service
            </button>
            <button class="btn-action" onclick="showSystemStatus()" id="systemStatusBtn">
                üìä System Status
            </button>
            <button class="btn-action" onclick="gitPull()" id="gitPullBtn">
                üì•
            </button>
        </div>
    </div>

    <!-- Log Cards Grid -->
    <div class="log-grid" id="logGrid">
        <!-- Bot cards will be populated by JavaScript -->
    </div>

    <div class="features">
        <h3>Features</h3>
        <ul>
            <li>Real-time bot status monitoring</li>
            <li>Start/Stop/Restart bots from the web interface</li>
            <li>Live log streaming with color-coded levels</li>
            <li>Full-text search across logs (Ctrl+F)</li>
            <li>Resource usage monitoring (CPU, Memory, Uptime)</li>
            <li>Auto-refresh every minute</li>
            <li>No SSH access required</li>
        </ul>
    </div>

    <div class="footer">
        Security Operations Team
    </div>
</div>

<!-- Toast Container -->
<div class="toast" id="toast">
    <div class="toast-title" id="toastTitle"></div>
    <div class="toast-message" id="toastMessage"></div>
</div>

<script>
    const API_BASE = 'http://sirt-lab-12.internal.example.com:8040/api';

    // Cached auth credentials (only needed for control actions)
    let cachedAuth = null;

    function getAuthHeader() {
        if (cachedAuth) return cachedAuth;
        const username = prompt('Username:');
        if (!username) return null;
        const password = prompt('Password:');
        if (!password) return null;
        cachedAuth = 'Basic ' + btoa(username + ':' + password);
        return cachedAuth;
    }

    let lastStatusData = null;
    let previousStatusData = null;
    let refreshInterval = null;
    let botsUnderControl = new Map(); // Track bots being controlled and what action (start/stop/restart)
    let isPaused = false; // Track pause state

    // Bot configuration
    const BOTS = [
        { key: 'toodles', name: 'Toodles', emoji: 'üéØ', port: 8032 },
        { key: 'msoar', name: 'MSOAR', emoji: 'ü§ñ', port: 8033 },
        { key: 'moneyball', name: 'MoneyBall', emoji: 'üí∞', port: 8034 },
        { key: 'jarvis', name: 'Jarvis', emoji: 'üõ°Ô∏è', port: 8035 },
        { key: 'barnacles', name: 'Barnacles', emoji: '‚öì', port: 8036 },
        { key: 'tars', name: 'TARS', emoji: '‚òÅÔ∏è', port: 8038 },
        { key: 'case', name: 'CASE', emoji: 'üè¢', port: 8041 },
        { key: 'jobs', name: 'All Jobs', emoji: '‚è∞', port: 8037 },
        { key: 'webserver', name: 'Web Server', emoji: 'üåê', port: 8039 }
    ];

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
        initializeBotCards();
        fetchStatus();
        startAutoRefresh();
    });

    function initializeBotCards() {
        const logGrid = document.getElementById('logGrid');
        const featuredCard = logGrid.querySelector('.featured');

        BOTS.forEach(bot => {
            const card = createBotCard(bot);
            logGrid.appendChild(card);
        });
    }

    function createBotCard(bot) {
        const card = document.createElement('div');
        card.className = 'log-card';
        card.id = `card-${bot.key}`;
        card.innerHTML = `
            <div class="card-header">
                <h3>${bot.emoji} ${bot.name}</h3>
                <div class="card-status">
                    <span class="status-dot stopped" id="dot-${bot.key}"></span>
                    <span id="status-${bot.key}">Checking...</span>
                </div>
            </div>
            <p id="desc-${bot.key}">${bot.name} bot logs</p>
            <div class="card-overlay" id="overlay-${bot.key}">
                <div class="card-overlay-content" id="info-${bot.key}">
                    <div><span>Status:</span><span>Checking...</span></div>
                </div>
                <div class="card-actions">
                    <button class="btn-card" onclick="window.open('http://sirt-lab-12.internal.example.com:${bot.port}', '_blank')">View Logs</button>
                    <button class="btn-card btn-start" id="start-${bot.key}" onclick="controlBot('${bot.key}', 'start')" disabled>Start</button>
                    <button class="btn-card" id="restart-${bot.key}" onclick="controlBot('${bot.key}', 'restart')" disabled>Restart</button>
                    <button class="btn-card btn-stop" id="stop-${bot.key}" onclick="controlBot('${bot.key}', 'stop')" disabled>Stop</button>
                </div>
            </div>
        `;
        return card;
    }

    async function fetchStatus() {
        try {
            const response = await fetch(`${API_BASE}/status`);

            if (!response.ok) {
                throw new Error('Failed to fetch status');
            }

            const data = await response.json();
            updateUI(data, lastStatusData);
            previousStatusData = lastStatusData;
            lastStatusData = data;
            updateLastUpdateTime();

        } catch (error) {
            console.error('Error fetching status:', error);
            showToast('Error', 'Failed to fetch bot status', 'error');
        }
    }

    function updateUI(data, previousData) {
        updateStatusBar(data);
        updateBotCards(data, previousData);
    }

    function updateStatusBar(data) {
        const { summary } = data;
        const running = summary.running;
        const total = summary.total;

        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const statusCount = document.getElementById('statusCount');

        if (running === total) {
            statusIndicator.textContent = '‚úÖ';
            statusText.textContent = 'All Systems Operational';
        } else if (running === 0) {
            statusIndicator.textContent = '‚ùå';
            statusText.textContent = 'All Systems Down';
        } else {
            statusIndicator.textContent = '‚ö†Ô∏è';
            statusText.textContent = 'Partial Systems Online';
        }

        statusCount.textContent = `${running} of ${total} bots running`;
    }

    function formatUptime(uptime) {
        if (!uptime) return 'N/A';

        // Format: "20-06:12:53" = 20 days, 6 hours, 12 minutes, 53 seconds
        // or "06:12:53" = 6 hours, 12 minutes, 53 seconds
        // or "12:53" = 12 minutes, 53 seconds

        const parts = uptime.split('-');
        let days = 0;
        let timeStr = uptime;

        if (parts.length === 2) {
            days = parseInt(parts[0]);
            timeStr = parts[1];
        }

        const timeParts = timeStr.split(':');

        if (days > 0) {
            const hours = parseInt(timeParts[0]);
            return `${days}d ${hours}h`;
        } else if (timeParts.length === 3) {
            const hours = parseInt(timeParts[0]);
            const minutes = parseInt(timeParts[1]);
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m`;
            }
        } else {
            const minutes = parseInt(timeParts[0]);
            return `${minutes}m`;
        }
    }

    function getProgressBarClass(value) {
        if (value < 50) return 'low';
        if (value < 80) return 'medium';
        return 'high';
    }

    function getUptimeBadge(uptime) {
        if (!uptime) return '';

        const hours = getUptimeHours(uptime);

        if (hours >= 168) { // 7 days
            return '<span class="uptime-badge excellent">üèÜ Excellent</span>';
        } else if (hours >= 24) { // 1 day
            return '<span class="uptime-badge good">‚ú® Good</span>';
        } else if (hours >= 4) { // 4 hours
            return '<span class="uptime-badge good">üëç Stable</span>';
        } else {
            return '<span class="uptime-badge poor">üîÑ Recent Restart</span>';
        }
    }

    function getUptimeDays(uptime) {
        if (!uptime) return 0;
        const parts = uptime.split('-');
        if (parts.length === 2) {
            return parseInt(parts[0]);
        }
        return 0;
    }

    function getUptimeHours(uptime) {
        if (!uptime) return 0;

        // Format: "20-06:12:53" = 20 days, 6 hours, 12 minutes, 53 seconds
        // or "06:12:53" = 6 hours, 12 minutes, 53 seconds
        // or "12:53" = 12 minutes, 53 seconds

        const parts = uptime.split('-');
        let days = 0;
        let timeStr = uptime;

        if (parts.length === 2) {
            days = parseInt(parts[0]);
            timeStr = parts[1];
        }

        const timeParts = timeStr.split(':');
        let hours = 0;
        let minutes = 0;

        if (timeParts.length === 3) {
            // HH:MM:SS format
            hours = parseInt(timeParts[0]);
            minutes = parseInt(timeParts[1]);
        } else if (timeParts.length === 2) {
            // MM:SS format (less than an hour)
            minutes = parseInt(timeParts[0]);
        }

        return days * 24 + hours + (minutes / 60);
    }

    function getTrendIndicator(current, previous, inverse = false) {
        if (!previous || previous === 0 || current === 0) return '';
        const diff = current - previous;
        const threshold = 5; // 5% change threshold

        if (Math.abs(diff) < threshold) {
            return '<span class="trend-indicator trend-stable">‚Äî</span>';
        }

        if (inverse) {
            // For metrics where lower is better (CPU, memory)
            if (diff > 0) return '<span class="trend-indicator trend-up">‚Üë</span>';
            return '<span class="trend-indicator trend-down">‚Üì</span>';
        } else {
            // For metrics where higher is better
            if (diff > 0) return '<span class="trend-indicator trend-down">‚Üë</span>';
            return '<span class="trend-indicator trend-up">‚Üì</span>';
        }
    }

    function updateBotCards(data, previousData) {
        const { bots } = data;
        const previousBots = previousData?.bots || {};

        Object.values(bots).forEach(bot => {
            const card = document.getElementById(`card-${bot.key}`);
            const dot = document.getElementById(`dot-${bot.key}`);
            const status = document.getElementById(`status-${bot.key}`);
            const desc = document.getElementById(`desc-${bot.key}`);
            const info = document.getElementById(`info-${bot.key}`);
            const startBtn = document.getElementById(`start-${bot.key}`);
            const restartBtn = document.getElementById(`restart-${bot.key}`);
            const stopBtn = document.getElementById(`stop-${bot.key}`);

            const previousBot = previousBots[bot.key];
            const controlAction = botsUnderControl.get(bot.key); // Get the action being performed
            const isUnderControl = controlAction !== undefined;

            // Detect status change and trigger animation
            if (previousBot && previousBot.status !== bot.status) {
                card.classList.remove('status-change-up', 'status-change-down');
                if (bot.status === 'running') {
                    setTimeout(() => card.classList.add('status-change-up'), 10);
                    showToast('Bot Started', `${bot.name} is now running`, 'success');
                    // Remove from control tracking when it successfully starts
                    botsUnderControl.delete(bot.key);
                } else if (bot.status === 'stopped') {
                    setTimeout(() => card.classList.add('status-change-down'), 10);
                    showToast('Bot Stopped', `${bot.name} has stopped`, 'info');
                }
                // Remove animation class after animation completes
                setTimeout(() => {
                    card.classList.remove('status-change-up', 'status-change-down');
                }, 1500);
            }

            // Update status dot (add pending state for bots under control)
            if (isUnderControl) {
                dot.className = 'status-dot error'; // Use error (orange) for pending
            } else {
                dot.className = `status-dot ${bot.status}`;
            }

            // Update status text based on control action
            if (isUnderControl) {
                if (controlAction === 'stop') {
                    status.textContent = 'Stopping...';
                } else if (controlAction === 'start') {
                    status.textContent = 'Starting...';
                } else if (controlAction === 'restart') {
                    status.textContent = 'Restarting...';
                }
            } else if (bot.status === 'running') {
                status.textContent = 'Live';

                // Show all PIDs if multiple processes are running
                if (bot.pid_count > 1) {
                    const pidList = bot.pids.join(', ');
                    desc.innerHTML = `<span style="color: #f56565; font-weight: 600;">‚ö†Ô∏è ${bot.pid_count} processes running!</span> ‚Ä¢ PIDs: ${pidList}`;
                } else {
                    desc.innerHTML = `Running ‚Ä¢ PID ${bot.pid}`;
                }
                card.classList.remove('status-down');

                // Get previous values for trend indicators
                const prevCpu = previousBot?.cpu_percent || 0;
                const prevMem = previousBot?.memory_percent || 0;

                // Update info overlay with progress bars and trends
                const uptimeBadge = getUptimeBadge(bot.uptime);
                info.innerHTML = `
                    <div class="metric-row">
                        <span class="metric-label">Uptime:</span>
                        <span class="metric-value">${formatUptime(bot.uptime)}</span>
                        <div style="flex: 1; margin-left: 8px;">${uptimeBadge}</div>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Memory:</span>
                        <span class="metric-value">${bot.memory_mb}MB (${bot.memory_percent.toFixed(1)}%)${getTrendIndicator(bot.memory_percent, prevMem, true)}</span>
                        <div class="progress-bar">
                            <div class="progress-fill ${getProgressBarClass(bot.memory_percent)}" style="width: ${bot.memory_percent}%"></div>
                        </div>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">CPU:</span>
                        <span class="metric-value">${bot.cpu_percent.toFixed(1)}%${getTrendIndicator(bot.cpu_percent, prevCpu, true)}</span>
                        <div class="progress-bar">
                            <div class="progress-fill ${getProgressBarClass(bot.cpu_percent)}" style="width: ${Math.min(bot.cpu_percent, 100)}%"></div>
                        </div>
                    </div>
                `;

                // Enable/disable buttons and show spinners if under control
                if (isUnderControl) {
                    startBtn.disabled = true;
                    restartBtn.disabled = true;
                    stopBtn.disabled = true;
                    startBtn.innerHTML = '<span class="spinner"></span>';
                    restartBtn.innerHTML = '<span class="spinner"></span>';
                    stopBtn.innerHTML = '<span class="spinner"></span>';
                } else {
                    startBtn.disabled = true;
                    startBtn.innerHTML = 'Start';
                    restartBtn.disabled = false;
                    restartBtn.innerHTML = 'Restart';
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = 'Stop';
                }

            } else if (bot.status === 'stopped') {
                status.textContent = 'Down';
                desc.textContent = 'Not running';
                card.classList.add('status-down');

                info.innerHTML = `
                    <div class="metric-row">
                        <span class="metric-label">Status:</span>
                        <span class="metric-value">üî¥ Stopped</span>
                    </div>
                `;

                if (isUnderControl) {
                    startBtn.disabled = true;
                    restartBtn.disabled = true;
                    stopBtn.disabled = true;
                    startBtn.innerHTML = '<span class="spinner"></span>';
                    restartBtn.innerHTML = '<span class="spinner"></span>';
                    stopBtn.innerHTML = '<span class="spinner"></span>';
                } else {
                    startBtn.disabled = false;
                    startBtn.innerHTML = 'Start';
                    restartBtn.disabled = true;
                    restartBtn.innerHTML = 'Restart';
                    stopBtn.disabled = true;
                    stopBtn.innerHTML = 'Stop';
                }

            } else {
                status.textContent = 'Error';
                desc.textContent = 'Status unknown';

                info.innerHTML = `
                    <div class="metric-row">
                        <span class="metric-label">Status:</span>
                        <span class="metric-value">‚ö†Ô∏è Error</span>
                    </div>
                `;

                if (isUnderControl) {
                    startBtn.disabled = true;
                    restartBtn.disabled = true;
                    stopBtn.disabled = true;
                    startBtn.innerHTML = '<span class="spinner"></span>';
                    restartBtn.innerHTML = '<span class="spinner"></span>';
                    stopBtn.innerHTML = '<span class="spinner"></span>';
                } else {
                    startBtn.disabled = false;
                    startBtn.innerHTML = 'Start';
                    restartBtn.disabled = false;
                    restartBtn.innerHTML = 'Restart';
                    stopBtn.disabled = false;
                    stopBtn.innerHTML = 'Stop';
                }
            }
        });
    }

    async function controlBot(botKey, action) {
        const auth = getAuthHeader();
        if (!auth) return;

        const actionText = action.charAt(0).toUpperCase() + action.slice(1);

        // Mark bot as under control and track which action
        botsUnderControl.set(botKey, action);

        // Disable all buttons for this bot
        ['start', 'restart', 'stop'].forEach(a => {
            const btn = document.getElementById(`${a}-${botKey}`);
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span>';
            }
        });

        // Update UI immediately to show pending state
        fetchStatus();

        try {
            const response = await fetch(`${API_BASE}/control/${botKey}/${action}`, {
                method: 'POST',
                headers: { 'Authorization': auth }
            });

            if (response.status === 401) {
                cachedAuth = null;
                showToast('Error', 'Invalid credentials', 'error');
                botsUnderControl.delete(botKey);
                fetchStatus();
                return;
            }

            const data = await response.json();

            if (data.success) {
                showToast('Success', data.message, 'success');

                // Poll more frequently for 6 seconds to catch status changes
                let pollCount = 0;
                const pollInterval = setInterval(() => {
                    fetchStatus();
                    pollCount++;
                    if (pollCount >= 12) { // 12 polls x 500ms = 6 seconds
                        clearInterval(pollInterval);
                        botsUnderControl.delete(botKey); // Stop tracking after polling
                        fetchStatus(); // Final refresh
                    }
                }, 500);

            } else {
                showToast('Error', data.message || `Failed to ${action} bot`, 'error');
                botsUnderControl.delete(botKey);
                fetchStatus();
            }

        } catch (error) {
            console.error(`Error ${action}ing bot:`, error);
            showToast('Error', `Failed to ${action} bot`, 'error');
            botsUnderControl.delete(botKey);
            fetchStatus();
        }
    }

    async function restartLogViewers() {
        const auth = getAuthHeader();
        if (!auth) return;

        const btn = document.getElementById('restartLogViewersBtn');
        const originalText = btn.innerHTML;

        // Disable button and show loading state
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Restarting...';

        showToast('Processing', 'Restarting log viewer services...', 'info');

        try {
            const response = await fetch(`${API_BASE}/log-viewers/restart`, {
                method: 'POST',
                headers: { 'Authorization': auth }
            });

            if (response.status === 401) {
                cachedAuth = null;
                showToast('Error', 'Invalid credentials', 'error');
                btn.disabled = false;
                btn.innerHTML = originalText;
                return;
            }

            const data = await response.json();

            if (data.success) {
                showToast('Success', data.message, 'success');
            } else {
                showToast('Error', data.message || 'Failed to restart log viewers', 'error');
            }

        } catch (error) {
            console.error('Error restarting log viewers:', error);
            showToast('Error', 'Failed to restart log viewers', 'error');
        } finally {
            // Re-enable button after a delay
            setTimeout(() => {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }, 3000);
        }
    }

    async function restartSelf() {
        const auth = getAuthHeader();
        if (!auth) return;

        const btn = document.getElementById('restartSelfBtn');
        const originalText = btn.innerHTML;

        // Disable button and show loading state
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Restarting...';

        showToast('Processing', 'Restarting this service...', 'info');

        try {
            const response = await fetch(`${API_BASE}/self-restart`, {
                method: 'POST',
                headers: { 'Authorization': auth }
            });

            const data = await response.json();

            if (data.success) {
                showToast('Success', 'Service restarting. Refresh the page in a few seconds.', 'success');
                // Auto-refresh after 5 seconds
                setTimeout(() => {
                    window.location.reload();
                }, 5000);
            } else {
                showToast('Error', data.message || 'Failed to restart service', 'error');
                btn.disabled = false;
                btn.innerHTML = originalText;
            }

        } catch (error) {
            // This error is expected if the service restarts before responding
            console.log('Service restart initiated (connection lost as expected)');
            showToast('Success', 'Service restarting. Refresh the page in a few seconds.', 'success');
            // Auto-refresh after 5 seconds
            setTimeout(() => {
                window.location.reload();
            }, 5000);
        }
    }

    async function gitPull() {
        const auth = getAuthHeader();
        if (!auth) return;

        const btn = document.getElementById('gitPullBtn');
        const originalText = btn.innerHTML;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Pulling...';

        showToast('Processing', 'Pulling latest changes from git...', 'info');

        try {
            const response = await fetch(`${API_BASE}/git-pull`, {
                method: 'POST',
                headers: { 'Authorization': auth }
            });

            const data = await response.json();

            if (data.success) {
                showToast('Git Pull', data.message, 'success');
            } else {
                showToast('Git Pull Failed', data.message || 'Failed to pull', 'error');
            }

        } catch (error) {
            console.error('Error during git pull:', error);
            showToast('Error', 'Failed to pull from git', 'error');
        } finally {
            setTimeout(() => {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }, 2000);
        }
    }

    async function showSystemStatus() {
        const btn = document.getElementById('systemStatusBtn');
        const originalText = btn.innerHTML;

        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Loading...';

        try {
            const response = await fetch(`${API_BASE}/system-status`);

            const data = await response.json();

            if (data.success) {
                const msg = `
üì¶ Disk: ${data.disk.used}/${data.disk.size} (${data.disk.percent})
üíæ Memory: ${data.memory.used}/${data.memory.total} (avail: ${data.memory.available})
‚ö° Load: ${data.load['1min']} / ${data.load['5min']} / ${data.load['15min']}
‚è±Ô∏è ${data.uptime}
                `.trim();

                alert(msg);
            } else {
                showToast('Error', 'Failed to get system status', 'error');
            }

        } catch (error) {
            console.error('Error getting system status:', error);
            showToast('Error', 'Failed to get system status', 'error');
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    async function controlAllBots(action) {
        const auth = getAuthHeader();
        if (!auth) return;
        if (!lastStatusData) return;

        const { bots } = lastStatusData;
        let targetBots = [];

        // Determine which bots to target based on action
        if (action === 'start') {
            targetBots = Object.values(bots).filter(bot => bot.status === 'stopped');
        } else if (action === 'stop' || action === 'restart') {
            targetBots = Object.values(bots).filter(bot => bot.status === 'running');
        }

        if (targetBots.length === 0) {
            showToast('Info', `No bots to ${action}`, 'info');
            return;
        }

        // Mark all target bots as under control and track which action
        targetBots.forEach(bot => botsUnderControl.set(bot.key, action));

        // Disable all quick action buttons
        ['startAllBtn', 'restartAllBtn', 'stopAllBtn'].forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.disabled = true;
        });

        showToast('Processing', `${action === 'start' ? 'Starting' : action === 'stop' ? 'Stopping' : 'Restarting'} ${targetBots.length} bot(s)...`, 'info');

        // Update UI immediately to show pending state
        fetchStatus();

        // Execute action for all target bots
        const promises = targetBots.map(bot =>
            fetch(`${API_BASE}/control/${bot.key}/${action}`, {
                method: 'POST',
                headers: { 'Authorization': auth }
            }).then(res => {
                if (res.status === 401) {
                    cachedAuth = null;
                    throw new Error('Invalid credentials');
                }
                return res.json();
            })
        );

        try {
            const results = await Promise.all(promises);
            const successCount = results.filter(r => r.success).length;
            const failCount = results.length - successCount;

            if (failCount === 0) {
                showToast('Success', `All ${targetBots.length} bot(s) ${action}ed successfully`, 'success');
            } else {
                showToast('Partial Success', `${successCount} succeeded, ${failCount} failed`, 'error');
            }

            // Poll more frequently for 8 seconds to catch all status changes
            let pollCount = 0;
            const pollInterval = setInterval(() => {
                fetchStatus();
                pollCount++;
                if (pollCount >= 16) { // 16 polls x 500ms = 8 seconds
                    clearInterval(pollInterval);
                    // Clear all bots from tracking
                    targetBots.forEach(bot => botsUnderControl.delete(bot.key));
                    fetchStatus(); // Final refresh
                }
            }, 500);

        } catch (error) {
            console.error(`Error in bulk ${action}:`, error);
            showToast('Error', `Failed to ${action} bots`, 'error');
            targetBots.forEach(bot => botsUnderControl.delete(bot.key));
            fetchStatus();
        } finally {
            // Re-enable quick action buttons after 8 seconds
            setTimeout(() => {
                ['startAllBtn', 'restartAllBtn', 'stopAllBtn'].forEach(btnId => {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = false;
                });
            }, 8000);
        }
    }

    function updateLastUpdateTime() {
        const lastUpdate = document.getElementById('lastUpdate');
        lastUpdate.textContent = 'Just now';
    }

    async function manualRefresh() {
        const reloadBtn = document.getElementById('reloadBtn');

        // Prevent multiple clicks while loading
        if (reloadBtn.classList.contains('loading')) {
            return;
        }

        // Add loading state
        reloadBtn.classList.add('loading');

        try {
            await fetchStatus();
        } finally {
            // Remove loading state after a minimum of 300ms for visual feedback
            setTimeout(() => {
                reloadBtn.classList.remove('loading');
            }, 300);
        }
    }

    function startAutoRefresh() {
        if (!isPaused) {
            refreshInterval = setInterval(() => {
                if (!isPaused) {
                    fetchStatus();
                }
            }, 60000); // Refresh every 60 seconds
        }
    }

    function togglePause() {
        isPaused = !isPaused;
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseIcon = document.getElementById('pauseIcon');
        const lastUpdate = document.getElementById('lastUpdate');

        if (isPaused) {
            // Paused state
            pauseIcon.textContent = '‚ñ∂Ô∏è';
            pauseBtn.title = 'Resume auto-refresh';
            pauseBtn.style.background = 'rgba(237, 137, 54, 0.3)';
            lastUpdate.textContent = 'Paused';
            lastUpdate.style.color = '#ed8936';

            // Clear the refresh interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }

            showToast('Auto-refresh Paused', 'You can now inspect elements', 'info');
        } else {
            // Resumed state
            pauseIcon.textContent = '‚è∏Ô∏è';
            pauseBtn.title = 'Pause auto-refresh';
            pauseBtn.style.background = '';
            lastUpdate.style.color = '';

            // Restart auto-refresh
            startAutoRefresh();

            // Fetch status immediately
            fetchStatus();

            showToast('Auto-refresh Resumed', 'Updates will continue every 60 seconds', 'success');
        }
    }

    function showToast(title, message, type = 'info') {
        const toast = document.getElementById('toast');
        const toastTitle = document.getElementById('toastTitle');
        const toastMessage = document.getElementById('toastMessage');

        toastTitle.textContent = title;
        toastMessage.textContent = message;

        toast.className = `toast ${type} show`;

        setTimeout(() => {
            toast.classList.remove('show');
        }, 4000);
    }

    // Update "last updated" text every second
    setInterval(() => {
        if (lastStatusData) {
            const lastUpdate = document.getElementById('lastUpdate');
            const now = new Date();
            const timestamp = new Date(lastStatusData.timestamp);
            const seconds = Math.floor((now - timestamp) / 1000);

            if (seconds < 60) {
                lastUpdate.textContent = `${seconds}s ago`;
            } else if (seconds < 3600) {
                const minutes = Math.floor(seconds / 60);
                lastUpdate.textContent = `${minutes}m ago`;
            } else {
                const hours = Math.floor(seconds / 3600);
                lastUpdate.textContent = `${hours}h ago`;
            }
        }
    }, 1000);
</script>
</body>
</html>
